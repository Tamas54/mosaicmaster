<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Königstiger | Élő Közvetítések</title>

  <!-- SEO Meta Tags -->
  <meta name="description" content="Königstiger élő közvetítések kezelő rendszere, amely lehetővé teszi YouTube, Twitch és Facebook streamek lejátszását és rögzítését." />
  <meta name="robots" content="index, follow" />

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  
  <!-- Universal Fetch Interceptor for Mixed Content Protection -->
  <script src="/static/fetch-interceptor.js"></script>
  <!-- HLS.js a HLS streamek támogatásához -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

  <style>
    :root {
      --primary-color: #0D1B2A;
      --secondary-color: #D4AF37;
      --accent-color: #A4161A;
      --stream-accent: #ef4444;
    }
    /* Global mosaic background */
    .background-image {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('/static/ravenna.jpg') no-repeat center center;
      background-size: cover;
      opacity: 0.1;
      z-index: -2;
    }
    header {
      padding: 0.3rem 0;
      position: relative;
      background-color: var(--primary-color);
    }
    header::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: url('/static/ravenna.jpg') no-repeat center center;
      background-size: cover;
      opacity: 0.1;
      z-index: -1;
    }
    
    /* Panel styles */
    .panel {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
    
    /* Stream form styling */
    .stream-form-control {
      transition: all 0.3s ease;
    }
    .stream-form-control:focus {
      border-color: var(--stream-accent);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
    }
    
    /* Stream player styles */
    .stream-container {
      position: relative;
      background-color: #000;
      border-radius: 0.5rem;
      overflow: hidden;
    }
    
    /* Media controls panel */
    .media-controls {
      background-color: rgba(13, 27, 42, 0.8);
      border-radius: 0.5rem;
    }
    
    /* Stream list styles */
    .stream-list-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1rem;
    }
    .stream-item {
      border-radius: 0.5rem;
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .stream-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .stream-item.recording {
      border-color: var(--stream-accent);
      background-color: rgba(239, 68, 68, 0.1);
    }
    
    /* Platform badges */
    .platform-badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: white;
    }
    .platform-youtube {
      background-color: #ff0000;
    }
    .platform-twitch {
      background-color: #9146ff;
    }
    .platform-facebook {
      background-color: #1877f2;
    }
    .platform-other {
      background-color: #666;
    }
    
    /* Status message styling */
    .status-message {
      border-radius: 0.5rem;
      padding: 1rem;
      margin: 1rem 0;
    }
    .status-message.error {
      background-color: #fee2e2;
      border-left: 4px solid #ef4444;
      color: #b91c1c;
    }
    .status-message.info {
      background-color: #dbeafe;
      border-left: 4px solid #2563eb;
      color: #1e40af;
    }
    .status-message.success {
      background-color: #dcfce7;
      border-left: 4px solid #22c55e;
      color: #15803d;
    }
    
    /* Recording indicator */
    .recording-indicator {
      display: inline-flex;
      align-items: center;
      background-color: var(--stream-accent);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }
    
    /* Debug Panel */
    .debug-panel {
      border: 1px solid #ccc;
      background-color: #f8f9fa;
      border-radius: 0.5rem;
      margin-top: 1rem;
      padding: 1rem;
      font-family: monospace;
      font-size: 0.875rem;
    }
    
    .debug-panel h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    
    .debug-panel pre {
      margin: 0;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }
    
    /* Pulse animation for buttons */
    @keyframes button-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse-animation {
      animation: button-pulse 2s infinite;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-900">
  <!-- Global background mosaic -->
  <div class="background-image"></div>

  <!-- Header -->
  <header class="text-white">
    <div class="container mx-auto px-6 flex justify-between items-center">
      <a href="/" class="text-2xl font-bold hover:text-[var(--secondary-color)]">Königstiger</a>
      <nav>
        <ul class="flex space-x-6">
          <li><a href="/" class="hover:text-[var(--secondary-color)]">Kezdőlap</a></li>
          <li><a href="/video-player.html" class="hover:text-[var(--secondary-color)]">Videólejátszó</a></li>
          <li><a href="/live-streams.html" class="text-[var(--secondary-color)] font-bold">Élő Közvetítések</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container mx-auto px-6 py-8">
    <div class="flex items-center mb-6">
      <i data-lucide="radio" class="w-8 h-8 text-[var(--stream-accent)] mr-3"></i>
      <h1 class="text-3xl font-bold">Élő Közvetítések</h1>
    </div>
    
    <p class="mb-8 text-gray-600">
      YouTube, Twitch és Facebook élő közvetítések lejátszása és rögzítése. 
      A felvett közvetítéseket automatikusan a videókönyvtárhoz adjuk.
    </p>
  
    <!-- Stream URL Form -->
    <section class="panel p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4 flex items-center">
        <i data-lucide="plus-circle" class="w-5 h-5 mr-2 text-[var(--stream-accent)]"></i>
        Stream hozzáadása
      </h2>
      
      <!-- URL Input Form -->
      <div class="mb-4">
        <label for="streamUrlTextarea" class="block text-sm font-medium text-gray-700 mb-2">Stream URL</label>
        <textarea id="streamUrlTextarea" class="w-full p-4 border border-gray-300 rounded-lg shadow-sm stream-form-control focus:outline-none" 
                  rows="3" placeholder="Illeszd be ide a stream URL-t (pl. https://www.youtube.com/watch?v=...)"></textarea>
      </div>
      
      <!-- Helper Buttons -->
      <div class="flex flex-wrap gap-2 mb-4">
        <button id="pasteFromClipboardBtn" class="inline-flex items-center px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">
          <i data-lucide="clipboard" class="w-4 h-4 mr-2"></i>
          Beillesztés vágólapról
        </button>
        
        <button id="clearUrlBtn" class="inline-flex items-center px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-colors">
          <i data-lucide="trash-2" class="w-4 h-4 mr-2"></i>
          Törlés
        </button>
      </div>
      
      <!-- Proxy Mode Toggle -->
      <div class="mb-4">
        <label class="inline-flex items-center cursor-pointer">
          <input type="checkbox" id="proxyMode" class="sr-only peer" checked>
          <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-[var(--stream-accent)] rounded-full peer dark:bg-gray-400 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-[var(--stream-accent)]"></div>
          <span class="ms-3 text-sm font-medium text-gray-700">
            Proxy mód (felvételkészítéshez szükséges)
          </span>
        </label>
      </div>
      
      <!-- URL Format Help -->
      <div class="p-4 bg-gray-50 rounded-lg mb-4">
        <p class="text-sm font-medium text-gray-700 mb-2">Támogatott URL formátumok:</p>
        <ul class="text-sm text-gray-600 space-y-1 ml-5 list-disc">
          <li>YouTube: https://www.youtube.com/watch?v=VIDEOID</li>
          <li>Twitch: https://www.twitch.tv/CHANNEL</li>
          <li>Facebook: https://www.facebook.com/USER/videos/VIDEOID</li>
        </ul>
      </div>
      
      <button id="addStreamBtn" class="w-full bg-[var(--stream-accent)] text-white py-3 rounded-lg hover:bg-red-600 transition flex items-center justify-center">
        <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
        Közvetítés hozzáadása
      </button>
      
      <!-- Status Message -->
      <div id="streamStatusMessage" class="status-message hidden"></div>
    </section>
    
    <!-- Stream Player Panel -->
    <section id="streamPlayerContainer" class="panel p-6 mb-8 hidden">
      <div class="flex justify-between items-center mb-4">
        <h2 id="streamTitle" class="text-xl font-semibold"></h2>
        <button id="closeStreamBtn" class="inline-flex items-center px-3 py-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg transition-colors">
          <i data-lucide="x" class="w-4 h-4 mr-1"></i>
          Bezárás
        </button>
      </div>
      
      <p id="streamInfo" class="text-sm text-gray-500 mb-4"></p>
      
      <!-- Stream Container -->
      <div class="stream-container mb-4 relative">
        <!-- Iframe Container -->
        <div id="streamPlayerEmbed" class="w-full aspect-video hidden"></div>
        
        <!-- Video Player -->
        <video id="streamPlayerVideo" controls class="w-full aspect-video hidden"></video>
        
        <!-- Loading Indicator -->
        <div id="streamLoadingIndicator" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
          <div class="text-white text-center">
            <i data-lucide="loader" class="w-12 h-12 mx-auto animate-spin mb-2"></i>
            <p>Stream betöltése...</p>
          </div>
        </div>
      </div>
      
      <!-- Media Controls Panel -->
      <div class="media-controls p-4 text-white hidden mb-4">
        <div class="flex flex-wrap items-center justify-center gap-6">
          <!-- Audio Track Select -->
          <div class="flex items-center space-x-2">
            <i data-lucide="volume-2" class="w-5 h-5 text-gray-300"></i>
            <select id="streamAudioTrackSelect" class="bg-gray-700 border-none rounded px-3 py-2 text-white text-sm focus:ring-[var(--secondary-color)]">
              <option value="">Hang betöltése...</option>
            </select>
          </div>
          
          <!-- Subtitle Track Select -->
          <div class="flex items-center space-x-2">
            <i data-lucide="subtitles" class="w-5 h-5 text-gray-300"></i>
            <select id="streamSubtitleTrackSelect" class="bg-gray-700 border-none rounded px-3 py-2 text-white text-sm focus:ring-[var(--secondary-color)]">
              <option value="off">Felirat kikapcsolva</option>
            </select>
          </div>
          
          <!-- Quality Select -->
          <div class="flex items-center space-x-2">
            <i data-lucide="settings" class="w-5 h-5 text-gray-300"></i>
            <select id="streamQualitySelect" class="bg-gray-700 border-none rounded px-3 py-2 text-white text-sm focus:ring-[var(--secondary-color)]">
              <option value="auto">Automatikus minőség</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- Stream Control Buttons -->
      <div class="flex flex-wrap gap-2">
        <button id="recordStreamBtn" class="inline-flex items-center px-4 py-2 bg-[var(--stream-accent)] hover:bg-red-600 text-white rounded-lg transition-colors">
          <i data-lucide="circle" class="w-4 h-4 mr-2"></i>
          Felvétel indítása
        </button>
        
        <button id="stopRecordingBtn" class="inline-flex items-center px-4 py-2 bg-[var(--stream-accent)] hover:bg-red-600 text-white rounded-lg transition-colors hidden pulse-animation">
          <i data-lucide="square" class="w-4 h-4 mr-2"></i>
          Felvétel leállítása
        </button>
      </div>
      
      <!-- Debug Panel (hidden by default) -->
      <div id="streamDebugPanel" class="debug-panel mt-4 hidden">
        <h3 class="text-sm font-bold mb-2">Stream Debug Információk</h3>
        <pre id="streamDebugInfo">Nincs elérhető adat</pre>
      </div>
    </section>
    
    <!-- Streams List -->
    <section class="panel p-6">
      <h2 class="text-xl font-semibold mb-6 flex items-center">
        <i data-lucide="list" class="w-5 h-5 mr-2 text-[var(--stream-accent)]"></i>
        Aktív közvetítések
      </h2>
      
      <div id="streamList" class="stream-list-container">
        <p id="noStreamsMessage" class="col-span-full text-center text-gray-500 py-8">Még nincs hozzáadott közvetítés</p>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="bg-[var(--primary-color)] text-white py-6 mt-8">
    <div class="container mx-auto px-6 text-center">
      <p>&copy; 2025 Königstiger GmbH. Minden jog fenntartva.</p>
    </div>
  </footer>

  <!-- JavaScript -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Activate Lucide Icons
      lucide.createIcons();
      
      // API alap URL
      const API_URL = '/api';
      
      // Stream variables
      let activeStreams = [];
      let currentStreamId = null;
      let isRecording = false;
      
      // Form elements
      const streamUrlTextarea = document.getElementById('streamUrlTextarea');
      const proxyModeToggle = document.getElementById('proxyMode');
      const addStreamBtn = document.getElementById('addStreamBtn');
      const streamStatusMessage = document.getElementById('streamStatusMessage');
      
      // Player elements
      const streamPlayerContainer = document.getElementById('streamPlayerContainer');
      const streamTitle = document.getElementById('streamTitle');
      const streamInfo = document.getElementById('streamInfo');
      const streamPlayerEmbed = document.getElementById('streamPlayerEmbed');
      const streamPlayerVideo = document.getElementById('streamPlayerVideo');
      const streamLoadingIndicator = document.getElementById('streamLoadingIndicator');
      const recordStreamBtn = document.getElementById('recordStreamBtn');
      const stopRecordingBtn = document.getElementById('stopRecordingBtn');
      const closeStreamBtn = document.getElementById('closeStreamBtn');
      const mediaControlsPanel = document.querySelector('.media-controls');
      
      // Debug panel
      const streamDebugPanel = document.getElementById('streamDebugPanel');
      const streamDebugInfo = document.getElementById('streamDebugInfo');
      
      // Press D + E + B + U + G keys together to toggle debug panel
      let keySequence = '';
      document.addEventListener('keydown', function(e) {
        keySequence += e.key.toLowerCase();
        if (keySequence.includes('debug')) {
          streamDebugPanel.classList.toggle('hidden');
          keySequence = '';
        }
        
        // Reset sequence after 2 seconds
        setTimeout(() => {
          keySequence = '';
        }, 2000);
      });
      
      // Helper function to log debug info
      function logDebug(message) {
        const timestamp = new Date().toISOString().split('T')[1].replace('Z', '');
        const formattedMessage = `[${timestamp}] ${message}`;
        console.log(formattedMessage);
        
        // Update debug panel if visible
        if (!streamDebugPanel.classList.contains('hidden')) {
          streamDebugInfo.textContent += formattedMessage + '\n';
          streamDebugInfo.scrollTop = streamDebugInfo.scrollHeight;
        }
      }
      
      // Clear debug panel
      function clearDebug() {
        streamDebugInfo.textContent = '';
      }
      
      // Helper buttons
      document.getElementById('pasteFromClipboardBtn').addEventListener('click', async function() {
        try {
          const text = await navigator.clipboard.readText();
          streamUrlTextarea.value = text;
          
          // Show success feedback
          this.innerHTML = '<i data-lucide="check" class="w-4 h-4 mr-2"></i> Beillesztve';
          this.classList.remove('bg-green-500', 'hover:bg-green-600');
          this.classList.add('bg-green-600');
          
          // Reset after 2 seconds
          setTimeout(() => {
            this.innerHTML = '<i data-lucide="clipboard" class="w-4 h-4 mr-2"></i> Beillesztés vágólapról';
            this.classList.remove('bg-green-600');
            this.classList.add('bg-green-500', 'hover:bg-green-600');
            lucide.createIcons();
          }, 2000);
          
          lucide.createIcons();
        } catch (err) {
          console.error('Cannot access clipboard:', err);
          showStreamStatus('A vágólap elérése sikertelen. Kérjük illeszd be manuálisan a stream URL-t.', 'error');
        }
      });
      
      document.getElementById('clearUrlBtn').addEventListener('click', function() {
        streamUrlTextarea.value = '';
        streamUrlTextarea.focus();
      });
      
      // Status message display
      function showStreamStatus(message, type) {
        streamStatusMessage.textContent = message;
        streamStatusMessage.className = `status-message ${type}`;
        streamStatusMessage.classList.remove('hidden');
        
        // Auto hide success/info messages after 5 seconds
        if (type === 'success' || type === 'info') {
          setTimeout(() => {
            streamStatusMessage.classList.add('hidden');
          }, 5000);
        }
      }
      
      // Add stream
      addStreamBtn.addEventListener('click', async () => {
        const streamUrl = streamUrlTextarea.value.trim();
        const proxyMode = proxyModeToggle.checked;
        
        if (!streamUrl) {
          showStreamStatus('Kérlek adj meg egy stream URL-t', 'error');
          streamUrlTextarea.focus();
          return;
        }
        
        // URL validation
        if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) {
          showStreamStatus('Érvénytelen URL formátum. Az URL-nek http:// vagy https:// előtaggal kell kezdődnie.', 'error');
          return;
        }
        
        clearDebug();
        logDebug(`Stream hozzáadása: ${streamUrl}, proxy: ${proxyMode}`);
        
        try {
          // Update button state
          addStreamBtn.disabled = true;
          addStreamBtn.innerHTML = '<i data-lucide="loader" class="w-5 h-5 mr-2 animate-spin"></i> Feldolgozás...';
          lucide.createIcons();
          
          showStreamStatus('Stream hozzáadása folyamatban...', 'info');
          
          const response = await fetch(`${API_URL}/streams`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              url: streamUrl,
              proxy_mode: proxyMode
            })
          });
          
          // Check for non-JSON responses first
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            throw new Error('A szerver nem JSON választ küldött');
          }
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Hiba a stream hozzáadása során');
          }
          
          const streamInfo = await response.json();
          logDebug(`Stream sikeresen hozzáadva: ${JSON.stringify(streamInfo)}`);
          
          // Success feedback
          showStreamStatus('Stream sikeresen hozzáadva', 'success');
          streamUrlTextarea.value = '';
          
          // Update streams list - majd késleltetéssel újra betöltjük, hogy a szerver frissíthesse az adatokat
          await loadStreams();
          
          // 2 másodperc múlva újra betöltjük, hogy biztosan frissüljön a recording_path
          setTimeout(async () => {
            logDebug("Streamek újratöltése 2 másodperc késleltetéssel...");
            await loadStreams();
          }, 2000);
          
          // Auto-play the newly added stream
          if (streamInfo && streamInfo.id) {
            // Új streamet keresünk az id alapján
            const newStreamInfo = activeStreams.find(s => s.id === streamInfo.id);
            if (newStreamInfo) {
              playStream(newStreamInfo);
            } else {
              logDebug(`Nem találtuk az új streamet az id alapján: ${streamInfo.id}`);
            }
          }
          
        } catch (error) {
          console.error('Error:', error);
          logDebug(`Hiba a stream hozzáadásánál: ${error.message}`);
          showStreamStatus(`Hiba: ${error.message}`, 'error');
        } finally {
          // Reset button state
          addStreamBtn.disabled = false;
          addStreamBtn.innerHTML = '<i data-lucide="plus" class="w-5 h-5 mr-2"></i> Közvetítés hozzáadása';
          lucide.createIcons();
        }
      });
      
      // Load streams
      async function loadStreams() {
        try {
          logDebug("Streamek betöltése...");
          const response = await fetch(`${API_URL}/streams`);
          
          if (!response.ok) {
            throw new Error(`Hibakód: ${response.status}, Státusz: ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Ellenőrizzük, hogy a válasz tartalmaz-e streams tömböt
          if (data.streams && Array.isArray(data.streams)) {
            const streams = data.streams;
            logDebug(`${streams.length} stream betöltve: ${JSON.stringify(streams)}`);
            // Debugoláshoz a konzolra is kiírjuk
            console.log("Streams betöltve:", streams);
            
            // Ellenőrizzük és kiemeljük azokat a streameket, amelyeknek van recording_path-ja
            streams.forEach(stream => {
              if (stream.recording_path) {
                logDebug(`Stream ${stream.id} már rendelkezik recording_path-szal: ${stream.recording_path}`);
              }
            });
            
            activeStreams = streams;
          } else {
            // Ha nincs streams tömb vagy nem tömb, akkor hiba
            logDebug(`Érvénytelen válaszformátum: ${JSON.stringify(data)}`);
            activeStreams = [];
            throw new Error("Érvénytelen válaszformátum: 'streams' tömb nem található");
          }
          
          const streamListEl = document.getElementById('streamList');
          const noStreamsMsg = document.getElementById('noStreamsMessage');
          
          if (activeStreams.length === 0) {
            streamListEl.innerHTML = '';
            streamListEl.appendChild(noStreamsMsg);
            noStreamsMsg.style.display = 'block';
            return;
          }
          
          noStreamsMsg.style.display = 'none';
          streamListEl.innerHTML = '';
          
          // Sort streams: recording first, then active, then by title
          activeStreams.sort((a, b) => {
            // Recording streams first
            if (a.is_recording && !b.is_recording) return -1;
            if (!a.is_recording && b.is_recording) return 1;
            
            // Then active streams
            if (a.status === 'active' && b.status !== 'active') return -1;
            if (a.status !== 'active' && b.status === 'active') return 1;
            
            // Finally sort by title
            return (a.title || '').localeCompare(b.title || '');
          });
          
          activeStreams.forEach(stream => {
            const streamItem = document.createElement('div');
            streamItem.className = `stream-item panel overflow-hidden ${stream.is_recording ? 'border-2 border-[var(--stream-accent)]' : ''}`;
            streamItem.dataset.id = stream.id;
            
            const platformClass = `platform-${stream.type}`;
            const title = stream.title || 'Ismeretlen cím';
            const isActive = stream.status === 'active';
            
            streamItem.innerHTML = `
              <div class="p-4">
                <div class="flex justify-between items-start mb-2">
                  <span class="platform-badge ${platformClass}">${stream.type.toUpperCase()}</span>
                  ${stream.is_recording ? '<span class="recording-indicator"><i data-lucide="radio" class="w-3 h-3 mr-1"></i> FELVÉTEL</span>' : ''}
                </div>
                <h3 class="font-medium text-lg mb-2 line-clamp-2" title="${title}">${title}</h3>
                ${!isActive ? '<p class="text-red-500 font-semibold mb-2">OFFLINE</p>' : ''}
                <div class="flex flex-wrap gap-2 mt-4">
                  <button class="play-stream-btn px-3 py-1.5 bg-[var(--stream-accent)] text-white rounded hover:bg-red-700 transition-colors flex items-center disabled:bg-gray-400 disabled:cursor-not-allowed" ${!isActive ? 'disabled' : ''}>
                    <i data-lucide="play" class="w-4 h-4 mr-1"></i>
                    Lejátszás
                  </button>
                  <button class="transcribe-stream-btn px-3 py-1.5 bg-purple-500 text-white rounded hover:bg-purple-700 transition-colors flex items-center">
                    <i data-lucide="file-text" class="w-4 h-4 mr-1"></i>
                    Leiratolás
                  </button>
                  <button class="delete-stream-btn px-3 py-1.5 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors flex items-center">
                    <i data-lucide="trash-2" class="w-4 h-4 mr-1"></i>
                    Törlés
                  </button>
                  <div class="transcription-buttons w-full mt-2">
                    <!-- Itt jelennek meg a leiratoláshoz kapcsolódó gombok -->
                  </div>
                </div>
              </div>
            `;
            
            streamListEl.appendChild(streamItem);
            
            // Create icons in the stream item
            lucide.createIcons({
              attrs: {
                class: "w-4 h-4"
              },
              root: streamItem
            });
            
            // Add event listeners
            streamItem.querySelector('.play-stream-btn').addEventListener('click', (e) => {
              e.stopPropagation();
              if (isActive) {
                playStream(stream);
              }
            });
            
            streamItem.querySelector('.delete-stream-btn').addEventListener('click', (e) => {
              e.stopPropagation();
              if (confirm('Biztosan el szeretnéd távolítani ezt a streamet?')) {
                removeStream(stream.id);
              }
            });
            
            // Leiratolás gomb - Most minden streamnél engedélyezzük, ha van recording_path
            // Debug logolás
            logDebug(`Stream ${stream.id}: is_recording=${stream.is_recording}, recording_path=${stream.recording_path}`);
            
            const transcribeBtn = streamItem.querySelector('.transcribe-stream-btn');
            if (transcribeBtn) {
              // Speciális kiemelés - ha a stream most már leiratolható
              if (stream.recording_path) {
                // Extra feltűnő megjelenés
                transcribeBtn.classList.remove('bg-purple-500', 'hover:bg-purple-700');
                transcribeBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'pulse-animation');
                transcribeBtn.style.fontWeight = 'bold';
                
                // Ha van recording_path, engedélyezzük a gombot
                transcribeBtn.disabled = false;
                transcribeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                transcribeBtn.title = "Felvétel leiratolása - KÉSZ A FELVÉTEL!";
              } else {
                // Ha nincs recording_path, letiltjuk a gombot
                transcribeBtn.disabled = true;
                transcribeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                transcribeBtn.title = "Nincs elérhető felvétel a leiratoláshoz";
              }
              
              // Minden esetben hozzáadjuk az eseménykezelőt
              transcribeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                logDebug(`Leiratolás gomb megnyomva: ${stream.id}`);
                transcribeStream(stream);
              });
            } else {
              logDebug(`Nem található transcribe-stream-btn a stream elemben: ${stream.id}`);
            }
            
            // Make whole item clickable if active
            if (isActive) {
              streamItem.addEventListener('click', (e) => {
                // Don't trigger if clicking on a button
                if (!e.target.closest('button')) {
                  playStream(stream);
                }
              });
              streamItem.classList.add('cursor-pointer');
            }
          });
          
        } catch (error) {
          console.error('Error loading streams:', error);
          logDebug(`Hiba a streamek betöltésénél: ${error.message}`);
          showStreamStatus('Hiba a streamek betöltésekor', 'error');
        }
      }
      
      // Play stream with HLS.js support - Completely rewritten
      function playStream(stream) {
        logDebug(`Stream lejátszás indítása: ${stream.id}, típus: ${stream.type}`);
        
        // Show loading indicator
        streamLoadingIndicator.classList.remove('hidden');
        
        // Update current stream
        currentStreamId = stream.id;
        isRecording = stream.is_recording;
        
        // Update UI
        streamTitle.textContent = stream.title || 'Élő közvetítés';
        streamInfo.textContent = `Típus: ${stream.type.toUpperCase()}`;
        mediaControlsPanel.classList.add('hidden');  // Initially hidden
        
        // Recording button state
        if (isRecording) {
          recordStreamBtn.classList.add('hidden');
          stopRecordingBtn.classList.remove('hidden');
        } else {
          recordStreamBtn.classList.remove('hidden');
          stopRecordingBtn.classList.add('hidden');
        }
        
        // Reset previous player
        if (window.hlsPlayer) {
          try {
            window.hlsPlayer.destroy();
            window.hlsPlayer = null;
            logDebug("Előző HLS lejátszó leállítva");
          } catch (err) {
            console.error("HLS player destroy error:", err);
            logDebug(`HLS leállítási hiba: ${err.message}`);
          }
        }
        
        // Reset video/embed elements
        streamPlayerVideo.pause();
        streamPlayerVideo.src = '';
        streamPlayerVideo.classList.add('hidden');
        streamPlayerEmbed.innerHTML = '';
        streamPlayerEmbed.classList.add('hidden');
        
        // Show player container
        streamPlayerContainer.classList.remove('hidden');
        
        // Scroll to player
        streamPlayerContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // Decide which player to use
        if (stream.proxy_url) {
          // Use proxy URL for HLS
          logDebug(`Proxy mód használata: ${stream.proxy_url}`);
          useHlsPlayer(stream);
        } 
        else if (stream.embed_url) {
          // Use embed URL for iframes
          logDebug(`Beágyazott mód használata: ${stream.embed_url}`);
          useEmbedPlayer(stream);
        } 
        else {
          // No valid URL
          logDebug("Nincs érvényes URL a streamhez");
          streamLoadingIndicator.classList.add('hidden');
          showStreamStatus('Nem található érvényes stream URL.', 'error');
        }
      }
      
      // Use HLS player for proxy streams
      function useHlsPlayer(stream) {
        // Get the full proxy URL
        let proxyUrl = stream.proxy_url;
        if (proxyUrl.startsWith('/')) {
          proxyUrl = window.location.origin + proxyUrl;
        }
        
        logDebug(`HLS stream inicializálása: ${proxyUrl}`);
        
        // Show video player, hide embed
        streamPlayerVideo.classList.remove('hidden');
        streamPlayerEmbed.classList.add('hidden');
        
        // Check for HLS.js support
        if (Hls.isSupported()) {
          logDebug("HLS.js támogatva van");
          
          try {
            // Create new HLS instance
            const hls = new Hls({
              debug: false,
              enableWorker: true,
              lowLatencyMode: true,
              backBufferLength: 90,
              maxBufferSize: 60 * 1000 * 1000, // 60MB
              maxBufferLength: 30,             // 30 seconds
              maxMaxBufferLength: 600          // Max 10 minutes
            });
            
            // Attach HLS events before loading source
            attachHlsEvents(hls);
            
            // Load source and attach to video element
            hls.loadSource(proxyUrl);
            hls.attachMedia(streamPlayerVideo);
            
            // Store global reference
            window.hlsPlayer = hls;
            
          } catch (error) {
            logDebug(`HLS inicializálási hiba: ${error.message}`);
            streamLoadingIndicator.classList.add('hidden');
            showStreamStatus(`HLS lejátszási hiba: ${error.message}`, 'error');
          }
        }
        // Fallback to native HLS support
        else if (streamPlayerVideo.canPlayType('application/vnd.apple.mpegurl')) {
          logDebug("Natív HLS támogatás használata");
          
          streamPlayerVideo.src = proxyUrl;
          streamPlayerVideo.addEventListener('loadedmetadata', function() {
            streamLoadingIndicator.classList.add('hidden');
            streamPlayerVideo.play().catch(err => {
              logDebug(`Natív lejátszási hiba: ${err.message}`);
              showStreamStatus(`Lejátszási hiba: ${err.message}`, 'error');
            });
          });
          
          // Error handling for native player
          streamPlayerVideo.addEventListener('error', function(e) {
            const error = e.target.error;
            logDebug(`Natív videó hiba: ${error.message}`);
            streamLoadingIndicator.classList.add('hidden');
            showStreamStatus(`Videó hiba: ${error.message}`, 'error');
          });
        }
        // No HLS support
        else {
          logDebug("HLS lejátszás nem támogatott");
          streamLoadingIndicator.classList.add('hidden');
          showStreamStatus('A böngésző nem támogatja a HLS streamek lejátszását. Próbálj másik böngészőt.', 'error');
        }
      }
      
      // Attach events to HLS player
      function attachHlsEvents(hls) {
        // Manifest loaded successfully
        hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
          logDebug(`HLS manifest betöltve: ${data.levels.length} minőségi szint`);
          
          // Hide loading indicator
          streamLoadingIndicator.classList.add('hidden');
          
          // Add quality levels if available
          if (hls.levels && hls.levels.length > 1) {
            populateStreamQualityLevels(hls);
            
            // Show controls panel
            mediaControlsPanel.classList.remove('hidden');
          }
          
          // Start playback
          streamPlayerVideo.play().catch(err => {
            logDebug(`Lejátszási hiba: ${err.message}`);
            showStreamStatus('A stream lejátszása nem indítható automatikusan. Kattints a videóra a lejátszáshoz.', 'info');
          });
        });
        
        // Media attached
        hls.on(Hls.Events.MEDIA_ATTACHED, function() {
          logDebug("HLS media csatolva");
        });
        
        // Level loaded
        hls.on(Hls.Events.LEVEL_LOADED, function(event, data) {
          logDebug(`HLS szint betöltve: ${data.level}`);
        });
        
        // Detailed error handling
        hls.on(Hls.Events.ERROR, function(event, data) {
          logDebug(`HLS hiba: ${data.type} - ${data.details}`);
          
          if (data.fatal) {
            logDebug(`Végzetes HLS hiba: ${data.type}`);
            
            // Hide loading indicator
            streamLoadingIndicator.classList.add('hidden');
            
            switch(data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                // Try to reload the stream
                logDebug('Hálózati hiba, újrapróbálkozás...');
                showStreamStatus('Hálózati hiba a streamben, újracsatlakozás...', 'info');
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                logDebug('Média hiba, helyreállítási kísérlet...');
                showStreamStatus('Média hiba, helyreállítási kísérlet...', 'info');
                hls.recoverMediaError();
                break;
              default:
                // Other fatal error, nothing to do
                showStreamStatus(`A stream nem játszható le: ${data.details}`, 'error');
                break;
            }
          }
        });
      }
      
      // Use embed player for iframe-based streams
      function useEmbedPlayer(stream) {
        logDebug(`Beágyazott lejátszó használata: ${stream.embed_url}`);
        
        // Hide video player, show embed
        streamPlayerVideo.classList.add('hidden');
        streamPlayerEmbed.classList.remove('hidden');
        
        // Create iframe for embedded player
        streamPlayerEmbed.innerHTML = `
          <iframe 
            width="100%" 
            height="100%" 
            src="${stream.embed_url}" 
            frameborder="0" 
            allowfullscreen
            allow="autoplay; encrypted-media; picture-in-picture">
          </iframe>
        `;
        
        // Hide loading indicator after a short delay
        setTimeout(() => {
          streamLoadingIndicator.classList.add('hidden');
        }, 1500);
      }
      
      // Populate quality levels for stream player
      function populateStreamQualityLevels(hls) {
        const qualitySelect = document.getElementById('streamQualitySelect');
        // Keep the "Auto" option
        qualitySelect.innerHTML = '<option value="auto">Automatikus minőség</option>';
        
        // Add quality levels (highest to lowest)
        const levels = hls.levels.slice().reverse();
        
        levels.forEach((level, index) => {
          const width = level.width || 'N/A';
          const height = level.height || 'N/A';
          const bitrate = level.bitrate ? Math.round(level.bitrate / 1000) : 'N/A';
          
          const option = document.createElement('option');
          option.value = hls.levels.length - 1 - index; // Original index
          option.textContent = `${width}x${height} (${bitrate}kbps)`;
          qualitySelect.appendChild(option);
        });
        
        // Event listener for changes
        qualitySelect.addEventListener('change', function() {
          const value = this.value;
          setQualityLevel(value, hls);
        });
      }
      
      // Set quality level
      function setQualityLevel(levelValue, hls) {
        if (hls) {
          if (levelValue === 'auto') {
            hls.currentLevel = -1; // Auto
          } else {
            hls.currentLevel = parseInt(levelValue);
          }
          
          logDebug(`Minőség beállítva: ${levelValue === 'auto' ? 'Automatikus' : levelValue}`);
        }
      }
      
      // Start recording
      async function startRecording() {
        if (!currentStreamId) {
          showStreamStatus('Nincs kiválasztott stream a felvételhez', 'error');
          return;
        }
        
        logDebug(`Felvétel indítása: ${currentStreamId}`);
        
        try {
          // Update UI - provide feedback to user
          recordStreamBtn.disabled = true;
          recordStreamBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i> Indítás...';
          lucide.createIcons();
          
          showStreamStatus('Felvétel indítása folyamatban...', 'info');
          
          const response = await fetch(`${API_URL}/streams/${currentStreamId}/record/start`, {
            method: 'POST'
          });
          
          // Log full response for debugging
          const responseText = await response.text();
          logDebug(`Felvétel indítási válasz: ${response.status} ${response.statusText}`);
          logDebug(`Válasz tartalma: ${responseText}`);
          
          // Parse JSON if possible
          let result;
          try {
            result = JSON.parse(responseText);
          } catch (e) {
            throw new Error(`Hibás JSON válasz: ${responseText}`);
          }
          
          if (result.status === 'recording') {
            isRecording = true;
            
            // Update UI
            recordStreamBtn.classList.add('hidden');
            stopRecordingBtn.classList.remove('hidden');
            
            showStreamStatus('Felvétel elindítva', 'success');
            
            // Refresh streams list
            await loadStreams();
          } else {
            throw new Error('Váratlan válasz a szervertől');
          }
          
        } catch (error) {
          console.error('Error starting recording:', error);
          logDebug(`Felvétel indítási hiba: ${error.message}`);
          showStreamStatus(`Hiba a felvétel indításakor: ${error.message}`, 'error');
        } finally {
          // Reset button
          recordStreamBtn.disabled = false;
          recordStreamBtn.innerHTML = '<i data-lucide="circle" class="w-4 h-4 mr-2"></i> Felvétel indítása';
          lucide.createIcons();
        }
      }
      
      // Stop recording
      async function stopRecording() {
        if (!currentStreamId || !isRecording) {
          return;
        }
        
        logDebug(`Felvétel leállítása: ${currentStreamId}`);
        
        try {
          // Update UI
          stopRecordingBtn.disabled = true;
          stopRecordingBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i> Leállítás...';
          lucide.createIcons();
          
          showStreamStatus('Felvétel leállítása folyamatban...', 'info');
          
          const response = await fetch(`${API_URL}/streams/${currentStreamId}/record/stop`, {
            method: 'POST'
          });
          
          // Log full response for debugging
          const responseText = await response.text();
          logDebug(`Felvétel leállítási válasz: ${response.status} ${response.statusText}`);
          logDebug(`Válasz tartalma: ${responseText}`);
          
          // Parse JSON if possible
          let result;
          try {
            result = JSON.parse(responseText);
          } catch (e) {
            throw new Error(`Hibás JSON válasz: ${responseText}`);
          }
          
          if (result.status === 'success') {
            isRecording = false;
            
            // Update UI
            recordStreamBtn.classList.remove('hidden');
            stopRecordingBtn.classList.add('hidden');
            
            let message = 'Felvétel leállítva';
            if (result.video_added) {
              message += ' és videóként hozzáadva';
            }
            
            // Ellenőrizzük, hogy van-e recording_path az eredményben
            if (result.recording_path) {
              logDebug(`Felvétel recording_path: ${result.recording_path}`);
              message += ' - Most már leiratolható';
              
              // Azonnal frissítsük a stream listát a recording_path információkkal
              const streamListItem = document.querySelector(`.stream-item[data-id="${currentStreamId}"]`);
              if (streamListItem) {
                const transcribeBtn = streamListItem.querySelector('.transcribe-stream-btn');
                if (transcribeBtn) {
                  transcribeBtn.disabled = false;
                  transcribeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                  transcribeBtn.title = "Felvétel leiratolása";
                  logDebug("Leiratoló gomb aktiválva a felvétel után");
                }
              }
            }
            
            showStreamStatus(message, 'success');
            
            // Refresh streams list - majd késleltetéssel újra betöltjük, hogy a szerver frissíthesse az adatokat
            await loadStreams();
            
            // 2 másodperc múlva újra betöltjük, hogy biztosan frissüljön a recording_path
            setTimeout(async () => {
              logDebug("Streamek újratöltése felvétel leállítása után 2 másodperc késleltetéssel...");
              await loadStreams();
            }, 2000);
          } else {
            throw new Error('Váratlan válasz a szervertől');
          }
          
        } catch (error) {
          console.error('Error stopping recording:', error);
          logDebug(`Felvétel leállítási hiba: ${error.message}`);
          showStreamStatus(`Hiba a felvétel leállításakor: ${error.message}`, 'error');
        } finally {
          // Reset button
          stopRecordingBtn.disabled = false;
          stopRecordingBtn.innerHTML = '<i data-lucide="square" class="w-4 h-4 mr-2"></i> Felvétel leállítása';
          lucide.createIcons();
        }
      }
      
      // Remove stream
      async function removeStream(streamId) {
        logDebug(`Stream eltávolítása: ${streamId}`);
        
        try {
          const response = await fetch(`${API_URL}/streams/${streamId}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            // Try to get error details
            let errorText = '';
            try {
              const errorData = await response.json();
              errorText = errorData.detail || '';
            } catch (e) {
              errorText = await response.text();
            }
            
            throw new Error(errorText || `Hibás válasz: ${response.status} ${response.statusText}`);
          }
          
          showStreamStatus('Stream sikeresen eltávolítva', 'success');
          logDebug(`Stream eltávolítva: ${streamId}`);
          
          // Refresh list
          await loadStreams();
          
          // Close player if this was the current stream
          if (currentStreamId === streamId) {
            closeStreamPlayer();
          }
          
        } catch (error) {
          console.error('Error removing stream:', error);
          logDebug(`Stream eltávolítási hiba: ${error.message}`);
          showStreamStatus(`Hiba a stream eltávolításakor: ${error.message}`, 'error');
        }
      }
      
      // Close stream player
      function closeStreamPlayer() {
        logDebug("Stream lejátszó bezárása");
        
        // Stop HLS.js if exists
        if (window.hlsPlayer) {
          try {
            window.hlsPlayer.destroy();
            window.hlsPlayer = null;
            logDebug("HLS lejátszó leállítva");
          } catch (err) {
            console.error("HLS player destroy error:", err);
            logDebug(`HLS leállítási hiba: ${err.message}`);
          }
        }
        
        // Stop player
        streamPlayerVideo.pause();
        streamPlayerVideo.src = '';
        streamPlayerVideo.classList.add('hidden');
        streamPlayerEmbed.innerHTML = '';
        streamPlayerEmbed.classList.add('hidden');
        
        // Hide container
        streamPlayerContainer.classList.add('hidden');
        
        currentStreamId = null;
        isRecording = false;
      }
      
      // Event listeners
      recordStreamBtn.addEventListener('click', startRecording);
      stopRecordingBtn.addEventListener('click', stopRecording);
      closeStreamBtn.addEventListener('click', closeStreamPlayer);
      
      // Auto focus textarea when page loads
      streamUrlTextarea.focus();
      
      // Add keyboard shortcut (Enter) to submit form
      streamUrlTextarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          addStreamBtn.click();
        }
      });
      
      // Stream leiratolás funkció
      async function transcribeStream(stream) {
        try {
          console.log("Leiratolás indítása streamhez:", stream);
          logDebug(`Leiratolás stream objektum: ${JSON.stringify(stream)}`);
          
          // Ha nincs megadva recording_path, próbáljuk meg frissíteni az aktuális stream adatokat
          if (!stream.recording_path) {
            try {
              logDebug("Nincs recording_path, stream adatok frissítése...");
              const refreshResponse = await fetch(`${API_URL}/streams/${stream.id}`);
              if (refreshResponse.ok) {
                const refreshedStream = await refreshResponse.json();
                logDebug(`Frissített stream adatok: ${JSON.stringify(refreshedStream)}`);
                
                // Ha a frissített objektumban van recording_path, használjuk azt
                if (refreshedStream.recording_path) {
                  stream = refreshedStream;
                  logDebug("Frissített stream adatok használata a recording_path-szal");
                } else {
                  showStreamStatus('A leiratoláshoz szükséges a felvétel elérési útja', 'error');
                  return;
                }
              } else {
                showStreamStatus('Nem sikerült frissíteni a stream adatait', 'error');
                logDebug(`Nem sikerült frissíteni a stream adatait: ${refreshResponse.status}`);
                return;
              }
            } catch (refreshError) {
              logDebug(`Hiba a stream adatok frissítésekor: ${refreshError.message}`);
              showStreamStatus('Hiba a stream adatok frissítésekor', 'error');
              return;
            }
          }
          
          logDebug(`Stream leiratolás indítása: ${stream.id}`);
          showStreamStatus('Leiratolás indítása...', 'info');
          
          // Stream elem gombjainak keresése
          const streamElement = document.querySelector(`.stream-item[data-id="${stream.id}"]`);
          const btnElement = streamElement ? streamElement.querySelector('.transcribe-stream-btn') : null;
          const buttonsContainer = streamElement ? streamElement.querySelector('.transcription-buttons') : null;
          
          // Töröljük a korábbi gombokat a konténerből
          if (buttonsContainer) {
            buttonsContainer.innerHTML = '';
          }
          
          // Leiratolás gomb frissítése
          if (btnElement) {
            btnElement.disabled = true;
            btnElement.innerHTML = '<i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i> Leiratolás...';
            lucide.createIcons({root: btnElement.parentElement});
          }
          
          // Leiratolás indítása
          const response = await fetch(`${API_URL}/streams/${stream.id}/transcribe`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recording_path: stream.recording_path
            })
          });
          
          if (!response.ok) {
            throw new Error(`Leiratolási hiba: ${response.status} ${response.statusText}`);
          }
          
          const result = await response.json();
          
          // Átiratolás ID elmentése
          const transcriptionId = result.transcription_id;
          
          showStreamStatus('Leiratolás sikeresen elindítva! A feldolgozás a háttérben folytatódik.', 'success');
          
          // Leiratolás leállítása gomb hozzáadása
          if (buttonsContainer) {
            const stopBtn = document.createElement('button');
            stopBtn.className = "inline-block px-3 py-1.5 bg-red-500 text-white rounded hover:bg-red-700 transition-colors mr-2";
            stopBtn.innerHTML = '<i data-lucide="square" class="w-4 h-4 mr-1"></i> Leiratolás leállítása';
            buttonsContainer.appendChild(stopBtn);
            lucide.createIcons({root: stopBtn});
            
            // Leállító gomb eseménykezelője
            stopBtn.addEventListener('click', async () => {
              try {
                stopBtn.disabled = true;
                stopBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i> Leállítás...';
                lucide.createIcons({root: stopBtn});
                
                // Leiratolás leállítása API hívás
                const stopResponse = await fetch(`${API_URL}/streams/${stream.id}/transcribe/stop`, {
                  method: 'POST'
                });
                
                if (!stopResponse.ok) {
                  throw new Error(`Leiratolás leállítási hiba: ${stopResponse.status} ${stopResponse.statusText}`);
                }
                
                const stopResult = await stopResponse.json();
                
                // Értesítés megjelenítése
                showStreamStatus('Leiratolás sikeresen leállítva', 'success');
                
                // Gomb állapot frissítése
                if (btnElement) {
                  btnElement.disabled = false;
                  btnElement.innerHTML = '<i data-lucide="file-text" class="w-4 h-4 mr-1"></i> Leiratolás';
                  lucide.createIcons({root: btnElement.parentElement});
                }
                
                // Leállítás gomb eltávolítása
                stopBtn.remove();
                
                // Letöltés gomb megjelenítése, ha van URL
                if (stopResult && stopResult.download_url) {
                  addDownloadButton(stream.id, stopResult.download_url, buttonsContainer);
                }
                
              } catch (error) {
                console.error('Error stopping transcription:', error);
                logDebug(`Hiba a leiratolás leállítása során: ${error.message}`);
                showStreamStatus(`Hiba a leiratolás leállítása során: ${error.message}`, 'error');
                
                // Gomb állapot visszaállítása hiba esetén
                stopBtn.disabled = false;
                stopBtn.innerHTML = '<i data-lucide="square" class="w-4 h-4 mr-1"></i> Leiratolás leállítása';
                lucide.createIcons({root: stopBtn});
              }
            });
          }
          
          // Ha sikerült elindítani, és van válasz polling vagy callback URL,
          // akkor várunk az eredményre és megjelenítjük, amikor elkészült
          if (result && result.status === "started") {
            // Itt lehetne polling, de helyette most elég a gomb megjelenítése
            
            // A leiratolás gomb ne legyen újra kattintható
            if (btnElement) {
              btnElement.disabled = true;
              setTimeout(() => {
                btnElement.innerHTML = '<i data-lucide="clock" class="w-4 h-4 mr-1"></i> Leiratolás folyamatban...';
                lucide.createIcons({root: btnElement.parentElement});
              }, 3000);
            }
          }
          
        } catch (error) {
          console.error('Error during stream transcription:', error);
          logDebug(`Hiba a stream leiratolása során: ${error.message}`);
          showStreamStatus(`Hiba a leiratolás során: ${error.message}`, 'error');
          
          // Gomb visszaállítása hiba esetén
          const btnElement = document.querySelector(`.stream-item[data-id="${stream.id}"] .transcribe-stream-btn`);
          if (btnElement) {
            btnElement.disabled = false;
            btnElement.innerHTML = '<i data-lucide="file-text" class="w-4 h-4 mr-1"></i> Leiratolás';
            lucide.createIcons({root: btnElement.parentElement});
          }
        }
      }
      
      // Letöltés gomb hozzáadása
      function addDownloadButton(streamId, downloadUrl, container) {
        const downloadBtn = document.createElement('a');
        downloadBtn.href = downloadUrl;
        downloadBtn.className = "inline-block px-3 py-1.5 bg-green-500 text-white rounded hover:bg-green-700 transition-colors";
        downloadBtn.innerHTML = '<i data-lucide="download" class="w-4 h-4 mr-1"></i> Leirat letöltése';
        downloadBtn.target = "_blank"; // Új ablakban nyitja meg
        
        // Hozzáadjuk a leiratolási gombok konténerébe
        if (container) {
          container.appendChild(downloadBtn);
        } else {
          // Ha nincs megadva konténer, keressük meg
          const streamElement = document.querySelector(`.stream-item[data-id="${streamId}"]`);
          const buttonsContainer = streamElement ? streamElement.querySelector('.transcription-buttons') : null;
          
          if (buttonsContainer) {
            buttonsContainer.appendChild(downloadBtn);
          } else {
            // Ha továbbra sem találjuk, hozzáadjuk a transcribe gomb szülőjéhez
            const btnElement = document.querySelector(`.stream-item[data-id="${streamId}"] .transcribe-stream-btn`);
            if (btnElement && btnElement.parentElement) {
              btnElement.parentElement.appendChild(downloadBtn);
            }
          }
        }
        
        lucide.createIcons({root: downloadBtn});
        
        // Feltűnő animáció
        downloadBtn.classList.add('pulse-animation');
        
        // Értesítés megjelenítése
        showStreamStatus('Leirat elkészült! Kattints a letöltés gombra.', 'success');
        
        return downloadBtn;
      }
      
      // Initial load
      loadStreams();
      
      // Log initial state
      logDebug("Königstiger Stream Modul inicializálva");
    });
  </script>
</body>
</html>
